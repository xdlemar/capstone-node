generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * =========================
 * Core Master Data
 * =========================
 */

model Item {
  id       BigInt  @id @default(autoincrement())
  sku      String  @unique
  name     String
  type     String  @default("supply")
  strength String?
  unit     String
  minQty   Decimal @default(0)
  isActive Boolean @default(true)

  batches    Batch[]
  movements  StockMove[]
  thresholds Threshold[]
  DisposalRequest DisposalRequest[]

  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  IssueLine    IssueLine[]
  TransferLine TransferLine[]
  CountLine    CountLine[]
}

model Location {
  id   BigInt @id @default(autoincrement())
  name String @unique
  kind String // WAREHOUSE | ROOM | STERILE | etc.

  // StockMove dual links
  asFromFor StockMove[] @relation("FromLoc")
  asToFor   StockMove[] @relation("ToLoc")

  // Issue relations (use unique relation names!)
  issuesFrom Issue[] @relation("IssueFromLoc")
  issuesTo   Issue[] @relation("IssueToLoc")

  // Transfer relations (use unique relation names!)
  transfersFrom Transfer[] @relation("XferFromLoc")
  transfersTo   Transfer[] @relation("XferToLoc")

  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  Threshold    Threshold[]
  CountSession CountSession[]
  DisposalRequest DisposalRequest[]
}

/**
 * =========================
 * Lots / Batches
 * =========================
 */

model Batch {
  id         BigInt    @id @default(autoincrement())
  itemId     BigInt
  lotNo      String?
  expiryDate DateTime?
  qtyOnHand  Decimal   @default(0)
  status     BatchStatus @default(ACTIVE)
  expiredAt  DateTime?
  quarantinedAt DateTime?
  disposedAt DateTime?

  item Item @relation(fields: [itemId], references: [id], onDelete: Cascade)

  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt
  StockMove  StockMove[]
  IssueAlloc IssueAlloc[]
  DisposalRequest DisposalRequest[]

  // one batch row per (item, lot, expiry)
  @@unique([itemId, lotNo, expiryDate])
  @@index([itemId, expiryDate])
  @@index([itemId, lotNo])
}

enum BatchStatus {
  ACTIVE
  EXPIRING
  EXPIRED
  QUARANTINED
  DISPOSED
}

enum DisposalStatus {
  PENDING
  APPROVED
  REJECTED
}

model DisposalRequest {
  id             BigInt         @id @default(autoincrement())
  batchId        BigInt
  itemId         BigInt
  qty            Decimal
  fromLocId      BigInt
  status         DisposalStatus @default(PENDING)
  reason         String?
  requestedBy    String?
  reviewedBy     String?
  reviewedAt     DateTime?
  rejectionReason String?
  disposedAt     DateTime?
  method         String?
  witness        String?
  referenceNo    String?

  batch   Batch    @relation(fields: [batchId], references: [id], onDelete: Restrict)
  item    Item     @relation(fields: [itemId], references: [id], onDelete: Restrict)
  fromLoc Location @relation(fields: [fromLocId], references: [id], onDelete: Restrict)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status, createdAt])
  @@index([batchId])
}

/**
 * =========================
 * Stock Ledger (idempotent)
 * =========================
 */

model StockMove {
  id         BigInt   @id @default(autoincrement())
  itemId     BigInt
  batchId    BigInt?
  fromLocId  BigInt?
  toLocId    BigInt?
  qty        Decimal
  reason     String // IN | OUT | ADJUSTMENT | DAMAGED | EXPIRED | RECEIPT | ISSUE | TRANSFER
  refType    String? // 'PO' | 'RECEIPT' | 'DELIVERY' | 'TRANSFER' | 'ISSUE' | 'COUNT' | ...
  refId      BigInt?
  eventId    String?  @unique // idempotency key
  occurredAt DateTime @default(now())
  createdAt  DateTime @default(now())

  item    Item      @relation(fields: [itemId], references: [id], onDelete: Restrict)
  batch   Batch?    @relation(fields: [batchId], references: [id], onDelete: SetNull)
  fromLoc Location? @relation("FromLoc", fields: [fromLocId], references: [id], onDelete: SetNull)
  toLoc   Location? @relation("ToLoc", fields: [toLocId], references: [id], onDelete: SetNull)

  @@index([itemId, occurredAt])
  @@index([refType, refId])
}

/**
 * =========================
 * Reorder Thresholds
 * =========================
 */

model Threshold {
  id         BigInt  @id @default(autoincrement())
  itemId     BigInt
  locationId BigInt
  minQty     Decimal @default(0)

  item     Item     @relation(fields: [itemId], references: [id], onDelete: Cascade)
  location Location @relation(fields: [locationId], references: [id], onDelete: Cascade)

  @@unique([itemId, locationId])
}

/**
 * =========================
 * Alerts (Low Stock / Expiry)
 * =========================
 */

enum NotificationType {
  LOW_STOCK
  EXPIRY
}

model Notification {
  id         BigInt           @id @default(autoincrement())
  type       NotificationType
  itemId     BigInt
  locationId BigInt?
  message    String
  createdAt  DateTime         @default(now())
  resolvedAt DateTime?

  @@index([type, itemId, locationId, resolvedAt])
}

/**
 * =========================
 * FEFO Issue (no barcode)
 * =========================
 */

model Issue {
  id        BigInt   @id @default(autoincrement())
  issueNo   String   @unique
  fromLocId BigInt
  toLocId   BigInt
  notes     String?
  createdAt DateTime @default(now())

  fromLoc Location    @relation("IssueFromLoc", fields: [fromLocId], references: [id], onDelete: Restrict)
  toLoc   Location    @relation("IssueToLoc", fields: [toLocId], references: [id], onDelete: Restrict)
  lines   IssueLine[]
}

model IssueLine {
  id        BigInt  @id @default(autoincrement())
  issueId   BigInt
  itemId    BigInt
  qtyReq    Decimal
  qtyIssued Decimal @default(0)
  notes     String?

  issue  Issue        @relation(fields: [issueId], references: [id], onDelete: Cascade)
  item   Item         @relation(fields: [itemId], references: [id], onDelete: Restrict)
  allocs IssueAlloc[]
}

model IssueAlloc {
  id          BigInt  @id @default(autoincrement())
  issueLineId BigInt
  batchId     BigInt
  qty         Decimal

  line  IssueLine @relation(fields: [issueLineId], references: [id], onDelete: Cascade)
  batch Batch     @relation(fields: [batchId], references: [id], onDelete: Restrict)
}

/**
 * =========================
 * FEFO Transfer (no barcode)
 * =========================
 */

model Transfer {
  id              BigInt         @id @default(autoincrement())
  transferNo      String         @unique
  fromLocId       BigInt
  toLocId         BigInt
  notes           String?
  createdAt       DateTime       @default(now())
  status          TransferStatus @default(PENDING)
  requestedBy     String?
  reviewedBy      String?
  reviewedAt      DateTime?
  rejectionReason String?

  fromLoc Location       @relation("XferFromLoc", fields: [fromLocId], references: [id], onDelete: Restrict)
  toLoc   Location       @relation("XferToLoc", fields: [toLocId], references: [id], onDelete: Restrict)
  lines   TransferLine[]
}

model TransferLine {
  id         BigInt  @id @default(autoincrement())
  transferId BigInt
  itemId     BigInt
  qty        Decimal
  notes      String?

  transfer Transfer @relation(fields: [transferId], references: [id], onDelete: Cascade)
  item     Item     @relation(fields: [itemId], references: [id], onDelete: Restrict)
}

enum TransferStatus {
  PENDING
  APPROVED
  REJECTED
}

/**
 * =========================
 * Cycle Counting (no scanner)
 * =========================
 */

enum CountStatus {
  OPEN
  POSTED
}

model CountSession {
  id         BigInt      @id @default(autoincrement())
  sessionNo  String      @unique
  locationId BigInt
  status     CountStatus @default(OPEN)
  notes      String?
  createdAt  DateTime    @default(now())

  location Location    @relation(fields: [locationId], references: [id], onDelete: Restrict)
  lines    CountLine[]
}

model CountLine {
  id         BigInt  @id @default(autoincrement())
  sessionId  BigInt
  itemId     BigInt
  countedQty Decimal
  systemQty  Decimal
  variance   Decimal
  notes      String?

  session CountSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  item    Item         @relation(fields: [itemId], references: [id], onDelete: Restrict)
}

/**
 * =========================
 * Receiving Checklist (no barcode)
 * =========================
 */

model ReceivingInspection {
  id          BigInt   @id @default(autoincrement())
  eventId     String   @unique // ties to StockMove.eventId of RECEIPT line
  sealsIntact Boolean?
  tempOk      Boolean?
  receivedBy  String?
  notes       String?
  createdAt   DateTime @default(now())
}
